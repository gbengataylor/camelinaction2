at the core of framework is a routing enging or routing-engine builder.
makes no assumptions of the type of data you need to process, as a result you can integrate with any kind of system, without the need to convert your data to a canonical format
OOTB suupport for > 280 protocols & data types. you can seamlessly plug in support for you own protocols, so no need for inncessary conversion = faster & lean

Camel is not an ESB even though it shares features such as routing, transofmation, orchestration, monitoring etc. it doesn't have a container or a reliable message bus but can be deployed in one
it's moer of an integration framework than an esb

main features:
¡	 Routing and mediation engine
moves a message around based on the routes configuration

¡	 Extensive component library
280 components that enable camel to connect over transports, use APIs and understand data formats

¡	 Enterprise integration patterns (EIPs)
see EIP book, Camel heavily based on the book, almost one to one relationship

¡	 Domain-specific language (DSL)
XML, java
you spend time on the integration tool, not the programming language
since it's real code you can use the existing programing langauge tooling support

¡	 Payload-agnostic route
it will route any kind of payload, no need to transform to canonical format to facilitate routing

¡	 Modular and pluggable architecture
an component can be loaded into camel even if it wasn't shipped with camel

¡	 Plain Old Java Object (POJO) model
java beans are first class citizens and can be used in your integrations

¡	 Easy configuration
covention over configuration paradigm followed wheneer possible

¡	 Automatic type converters
built-in type-converter ships with > 360 converters. for e.g no more rules for arrays to strings etc

¡	 Lightweight core ideal for microservices
it's lighweight, total library 4.9MB having 1.3MB runtine dependencies
can be embedded or deployed wherever - standalone app, microservice, web app, spring, JEE, OSGi, Spring Boot, aws, k9s, cloud foundry
not designed to be a server or esb but to be embedded in whatever runtime you choose. you just need java

¡	 Cloud ready
cloud-native + provides connectors to SaaS providers 

¡	 Test kit
available to test camel apps. same kit used to test camel, includes > 18K unit tests
¡	 Vibrant community


**Camels Message Model
uses two abstractions MEssage (contains the data) & Exchange (exchange of messages in and out messages)

Message
contains - headers, attachments, body
identified by java.lang.String
Headers are of type java.lang.Object. stored as a map within the message. 
attachments aree optional, typcially used for the web service and email components

Body - type java.lang.Onject

Message also has a Fault Flag

Exchange
pattern properties
inOnly (event message) e.g JMS
InOut - request response message e.g HTTO

components
- exchange id - automatically generated by camel
- MEP (message exchange pattern) - inOut vs inOnly
- exception - for error handling
- properties - similar to message headers but last the duration of entire echange. contain global level info whereas message headers specific to particular message. these properties can be retrieved at the length of the exchange
- in message - mandatory
- out message - exists if MEP is InOut



**ARCHITECTURE
from 10K feet
- Camel Context inludes the following
- Routing engine - a dsl wires endpoints and processors together to form routes
- Routes
- Message filter processor
- Processors - transforms & manipulates messages. handles things between endpoingts like EIPS, routing, transformation etc
- content-based router proceoor
- components which provide a uniform endpoint interface and connect to other systems

Camelcontext - container of sorts, camels runtime system,
contians services - components, endpoints, routes, type converters, data formats, regisry, languages

routing engine - moved messages under the hood. not exposed to dev but does all the heavy lifting, ensuring messaes routed properly

routes - a chain of processes.exactly one imput source. if syntax allows for multiple inputs, camel just clones the route definition

DSL - used to define routes. provides both java and xml

processor - a route is composed of a graph of processors. it is a core camel concept that represents a node capable of using, creating or modifying an incoming message. they can be impls of EIPs, producers of specific components or a dev's custom creation
a consumer consumes the message from external and brings message into the route. message passed to processors. producer sends to external systems

component - main extension point in camel. it has > 280 components. you can create custom components.
they are associated with a name used in a URI and act as a factory of endpoints
for e.g FileComponent is referred to by file in a URI

endpoint - models the end of a channel through which a system can send or receive messages
for e.g file:data/inbox?delay=5000
file - scheme (component)
data/inbox - context patch
delay=5--- options

producer - camel abstraction that refers to an entity capable of sending a message to an endpoint. for example JmsProducer maps message to javax.jms.Message before sending to JMS destination
hide complexity of interacting with particular transport. producer does all the heavy lifting

consumer - receives message produced by external system, wraps in an exchange and sends to be processed. they are the source of exchanges being routed in camel
2 types - 
event-driven - async, listens on a particular messaging channel (tcp/ip port, jms queue, twitter handle etc). waits for message to arrive, it wakes up and takes message for processing
& polling consumers - actively fetches messages.sync as it won't poll for more until the current message is finished
